name: Build and Push Anki Sync Server

# This workflow is triggered on a schedule, on a push to the main branch,
# or when manually dispatched.
on:
  schedule:
    - cron: '0 3 * * *'
  # Run when a push is made to the main branch
  push:
    branches:
      - main
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  build-and-push-image:
    name: Build and Push Docker Image
    # Use the latest version of Ubuntu to run the job
    runs-on: ubuntu-latest

    # Set permissions for the job to be able to write to GitHub Packages (GHCR)
    permissions:
      contents: read
      packages: write

    steps:
      # Step 1: Check out the repository's code
      - name: Check out repository
        uses: actions/checkout@v4

      # Step 2: Fetch the latest Anki release tag from the official repository
      - name: Get latest Anki version
        id: get_version
        # This command uses the GitHub API and jq to get the latest release,
        # extracts the tag name (e.g., "24.04.1"), and sets it as an output.
        run: |
          LATEST_VERSION=$(curl -s "https://api.github.com/repos/ankitects/anki/releases/latest" | jq -r '.tag_name')
          echo "version=${LATEST_VERSION}" >> $GITHUB_OUTPUT
        shell: bash

      # Step 3: Log in to Docker Hub. This is needed for the check step to avoid rate limits.
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Step 4: Check if the Docker image for the latest version already exists
      - name: Check if image with tag exists
        id: check_image
        # Use docker manifest inspect. It returns a non-zero exit code if the manifest does not exist.
        # We use continue-on-error to prevent the workflow from failing if the image doesn't exist.
        run: |
          docker manifest inspect ${{ secrets.DOCKERHUB_USERNAME }}/anki-sync-server:${{ steps.get_version.outputs.version }} > /dev/null 2>&1
        continue-on-error: true

      # Step 5: Log in to GitHub Container Registry (GHCR) if the image needs to be built
      - name: Log in to GitHub Container Registry
        if: steps.check_image.outcome == 'failure'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # The GITHUB_TOKEN is a special secret automatically created by Actions
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 6: Set up QEMU for multi-architecture builds if the image needs to be built
      - name: Set up QEMU
        if: steps.check_image.outcome == 'failure'
        uses: docker/setup-qemu-action@v3

      # Step 7: Set up Docker Buildx if the image needs to be built
      - name: Set up Docker Buildx
        if: steps.check_image.outcome == 'failure'
        uses: docker/setup-buildx-action@v3

      # Step 8: Extract metadata (tags and labels) for the Docker image if it needs to be built
      - name: Extract Docker metadata
        id: meta
        if: steps.check_image.outcome == 'failure'
        uses: docker/metadata-action@v5
        with:
          # Create image names for both Docker Hub and GHCR
          images: |
            ${{ secrets.DOCKERHUB_USERNAME }}/anki-sync-server
            ghcr.io/${{ github.repository }}
          tags: |
            # Tag with the specific Anki version (e.g., 24.04.1)
            type=raw,value=${{ steps.get_version.outputs.version }}
            # Also tag as 'latest' for convenience
            type=raw,value=latest

      # Step 9: Build and push the Docker image if it does not already exist
      - name: Build and push
        if: steps.check_image.outcome == 'failure'
        uses: docker/build-push-action@v5
        with:
          # The context is the root of the repository
          context: .
          file: ./Dockerfile
          # Build for both AMD64
          platforms: linux/amd64
          # Only push the image if the event is not a pull request
          push: ${{ github.event_name != 'pull_request' }}
          # Use the tags generated by the metadata action
          tags: ${{ steps.meta.outputs.tags }}
          # Use the labels generated by the metadata action
          labels: ${{ steps.meta.outputs.labels }}
          # Pass the latest Anki version as a build argument to the Dockerfile
          build-args: |
            ANKI_VERSION=${{ steps.get_version.outputs.version }}

      # Step 10: Report that the build was skipped
      - name: Report skipped build
        if: steps.check_image.outcome == 'success'
        run: echo "Image with tag ${{ steps.get_version.outputs.version }} already exists. Skipping build."

